My design for this assignment is focused on how to implement all the classes, method and interfaces that we have created before to draw all shapes in motions on the panel using swing. I have taken similar approach as before. I prioritized making everything object oriented so that later if someone wants to make any changes, he/she don’t need to modify the code that already have. Instead, they can just created another class or interface that extends or implements from it.

For model, I designed 3 interfaces which are IModel for the model, IMotion for motions. and IShape for shapes. Interfaces for motions and shapes make this project easier to be extended when the future developers want to add other shapes or offer new motions for the animation. And I made abstract classes out of these two interfaces as well, which holds all common methods and fields for generic motions and shapes.
For different shapes at this point (oval and rectangle), the only difference is the print message they are transferring to when being created. So having all the other common methods in abstract class including the parameters' invalidity checking and getter methods makes my code more concise and easier to read. In oder to make my program solid, I added a ReadOnlyShape class which possesses only getter functions and the objects made out of which will be rendered to the controller so that no one could modify these shapes outside the model. Whereas there is a generic shape class that has all setter and getter functions to retrieve and set all attributes of shape objects.
As for motions, they are the main components to make the animation possible and we offer moving, scaling, and changing color here. I designed a motion interface, abstract motion classes, and three concrete motion classes derived out of the abstract class.
Each motion has three common fields which are the name of the shape that this motion will be executed on, the start time and the end time. They all sit in the abstract class and all other attributes depicting this motion are dispersed in their own class. Functions in the abstract motion class are setters and getters to set and get attributes of motion object.
Finally, the model provides all the methods for the animation. New created shapes and animations will be stored in several data structures which can be retrieved when needed by the controller. Here I make names of those shapes as their unique id, so no duplicate name is allowed. A newly created motion must meet four requirements: 1. the shape with the input name that this motion will be executed on must exist. 2. The time interval during which this motion will be executed must be within this shape's existing time. 3. Two same type of motions cannot be executed on a shape object during an overlapping time interval. (All the above three requirements will be checked by the private check Validity function) 4. For this motion itself, it must meet all the validity requirements specified in their own class including valid time interval, valid lengths, and so on. When the description of animations is requested, I first sort all the shape and motions according to their start time and use a StringBuilder to append all the descriptions in a specific format. 

For controller, I designed one interface, one abstract class out of this interface and two concrete controller class. Here, the controllerText associates the model with the TextualView to get the textual output of the animation and the ControllerGui associates the model with the VisualView to display the animation on screen.
Which controller will be called depends on the request send by users. 
With multiple controllers to choose from, I have implemented the factory pattern so the program knows which controllers to operate based on the user input. When new controllers are to be added, we could just added new options in the ControllerFactory without touching any other code. Similarly I have implemented the same technique on my view portion of this project,


For view, I have created three interfaces, they are IView, IDrawingPanel and IViewShapes. 
The shape objects here are specific for the view and need to be differentiate from the model shapes. But the idea behind these shape class are inherently
The same. They all have shape interface, abstract shape class and concrete shape class for the purpose of flexibility and extendability. Basically, the controller will retrieve all the model shapes' information from the model and create new view shapes then, deliver them to the view, by which we can separate the model and the view properly. 
In order to display two kinds of animations, I created two view classes that are in charge of different output. The VisualView is for visual animation shown on the screen and the TextualView is for the textual output which will have all the transformations in a certain format in a file. 
And the drawingPanel class will set up a visual panel and draw shapes on it, that is how the VisualView is going to display the animation. By calling refresh frame by frame, we will see successive movement on the panel.
